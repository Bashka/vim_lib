*vim_lib.txt*		Для Vim версии 7.0.		*vim_lib*

			РУКОВОДСТВО ПО VIM_LIB

1. Описание						|vim_lib-description|
2. Пакет base						|vim_lib-base|
  2.1. Object						|vim_lib-base-object|
  2.2. Stack						|vim_lib-base-stack|
  2.3. List						|vim_lib-base-list|
  2.4. Dict						|vim_lib-base-dict|
  2.5. Test						|vim_lib-base-test|
3. Пакет sys						|vim_lib-sys|
  3.1. Buffer						|vim_lib-sys-buffer|
  3.2. Plugin						|vim_lib-sys-plugin|
  3.3. NullPlugin					|vim_lib-sys-nullplugin|

================================================================================
1. Описание						*vim_lib-description*

Vim_Lib - это объектно-ориентированная библиотека, включающая множество
готовых решений низкоуровневых задач на языке VimScript. Библиотека
подключается в виде autoload плагина, что позволяет загружать ее компоненты
"по требованию".

Библиотека имеет многоуровневую, вложенную структуру, которая включает:

  - Пакеты - каталоги классов, группирующие их по области применения. К ним
    относятся такие пакеты, как |vim_lib-base|, |vim_lib-sys| и так далее
  - Классы - минимальные компоненты библиотеки, решающие конкретные задачи и
    объединяющие общую логику. К ним относятся такие классы, как 
    |vim_lib-base-Object|, |vim_lib-base-Stack|, |vim_lib-sys-Plugin| и так далее

Все классы библиотеки являются дочерними, по отношению к классу 
|vim_lib-base-Object|, что унифицирует их интерфейс и приводит к единому
формату использования, а именно:
>
	let s:Stack = vim_lib#base#Stack# " Создаем псевдоним (alias) класса
	let s:stk = s:Stack.new()         " Инстанциируем класс
	" Используем объект
	let s:stk.push(1)
	echo s:stk.pop()

Из примера видно, что программный код, использующий любой класс библиотеки,
состоит из трех компонентов:

  - Создание псевдонима - данная операция позволяет не только сократить имя
    класса, но и явно назвать те компоненты библиотеки, которые используются
    данным кодом
  - Инстанциация класса - создание экземпляра класса с помощью конструктора new 
  - Использование объекта - применение объекта для решения конкретных задач

Помимо классов, библиотека включает подробную документацию их интерфейса и
модульные тесты, гарантирующие ожидаемую работу компонентов. Документация
содержится внутри файлов классов, а тесты в каталогах "tests" каждого пакета
библиотеки.

================================================================================
2. Пакет base						*vim_lib-base*

Пакет base включает базовые, низкоуровневые классы библиотеки.

2.1. Object						*vim_lib-base-object*
-----------

Класс Object является родителем всех классов библиотеки и реализует базовый 
интерфейс объектов, а именно:

  - Структура объектов - свойства 'class' и 'parent', определенные во всех 
    объектах
  - Конструктор - метод 'new', используемый для инстанциации класса
  - Механизм наследования - метод 'expand', используемый для расширения
    функциональности класса за счет реализации его потомков
  - Базовая типизация - метод 'typeof', используемый для определения
    принадлежности класса к целевой иерархии наследования

Все объекты класса Object или его подклассов представляют обычные словари. При
этом свойства определены как экземпляры этих словарей, а методы как 'dict' 
функции. Для связи объекта с классом, его породившим, создается свойство
'class', которое ссылается на объект класса. Если объект является экземпляром
подкласса, то в нем определяется свойство 'parent', содержащее ссылку на
соответствующий объект надкласса. Аналогичную ссылку имеют все подклассы. 
Другими словари при создании объекта дочернего класса, автоматически создаются 
объекты всех надклассов, связанные снизу вверх с помощью свойства 'parent'. 
Такое решение позволяет не смешивать свойства объектов между собой, а так же 
разделять логику конструктора между объектами.

Для создания объекта, достаточно воспользоваться конструктором 'new':
>
	let s:obj = s:MyClass.new() " Метод может принимать параметры

Конструктор, как и все методы класса Object являются статичными, то есть не
переносятся в экземпляр класса, что не позволяет вызвать конструктор от имени
объекта. Если же необходимо создать объект того же класса, что и исходный
объект, необходимо использовать ссылку 'class':
>
	let s:otherObj = s:obj.class.new() " class ссылается на s:MyClass

Основой целью класса Object является реализация механизма наследования и
расширения существующих классов. Это достигается благодаря методу 'expand'.
Для расширения класса через наследование необходимо:

  - Использовать метод 'expand' у надкласса для создания заготовки
  - Реализовать конструктор 'new'
  - Реализовать методы класса

Метод 'expand' создает новый словарь и добавляет к нему все методы класса
Object, а так же свойство 'parent', которое ссылается на родительский класс.
Этот словарь будет возвращен из метода и определит заготовку будущего класса.

Для реализации конструктора нового класса необходимо переопределить метод
'new' для заготовки, создаваемой методом 'expand'. Конструктор может принимать
любое число аргументов, с помощью которых будут инициализировать экземпляры
этого класса. Конструктор должен создавать новые словари для всех надклассов, 
определять ссылки 'class' и 'parent', а так же инициализировать свойства
будущего объекта. Сделать это можно следующим способом:

  - Создать заготовку объекта с помощью метода 'bless' класса Object, передав
    ему результат работы конструктора надкласса
  - Определить для полученной заготовки свойства не переопределяя ссылки
    'parent' и 'class'
  - Вернуть получившийся объект 

После определения конструктора класса, необходимо реализовать его методы. Для
этого достаточно создать 'dict' функции для полученного класса, которые будут
обращаться к свойствам экземпляров этого класса через переменную 'self':
>
	function! s:MyClass.getA()
		return self.a
	endfunction

Важно помнить, что методы класса относятся к тому объекту, в классе которого
они были объявлены. Так, если в классе Parent реализован метод getA, то в
объекте его подкласса Child, этот метод будет доступен только через ссылку
'parent' объекта:
>
	echo s:child.parent.getA()

Это связано с тем, что для каждого класса создается отдельный объект, хранящий
его свойства.

Более подробно познакомиться с механизмом наследования вы можете на примере
классов "vim_lib/autoload/base/tests/Object/Parent" и 
"vim_lib/autoload/base/tests/Object/Child".

2.2. Stack						*vim_lib-base-stack*
----------

Класс Stack представляет список данных, организованный по принципу LIFO. Класс
реализует несколько методов манипулирования стеком, а так же метод 'length',
вычисляющий текущую длину стека (число элементов в нем).

Изначально экземпляр данного класса пуст, для добавления в него элементов
используется метод 'push', который вставляет данные в ввершину стека. Метод
'pop' наоборот выталкивает данные из вершины и возвращает их. Если необходимо
получить данные с вершины стека без выталкивания, используется метод
'current'.

Пример:
>
	let s:Stack = vim_lib#base#Stack#
	let s:stk = s:Stack.new()
	call s:stk.push(1)
	call s:stk.push(2)
	echo s:stk.length() " 2
	echo s:stk.pop()    " 2
	echo s:stk.pop()    " 1
	echo s:stk.length() " 0

2.3. List						*vim_lib-base-list*
---------

Класс List представляет упорядоченный, изменяемый список данных с доступом к 
элемента по индексу. Класс реализует основные методы для доступа к элементам 
списка, управления им и получения информации о его структуре.

Список List может быть инициализирован при инстанциации любым массивом, либо
быть пустым. Для определения или получения значений элементов списка 
используется метод 'item'. Для выделения среза используется метод 'sec'. Метод
'length' позволяет определить длину (число элементов) списка.

Пример:
>
	let s:List = vim_lib#base#List#
	let s:lst = s:List.new([1,2,3])
	call s:lst.item(0, 5)
	echo s:lst.item(0)    " 5
	echo s:lst.length()   " 3
	echo s:lst.list()     " [5,2,3]

2.4. Dict						*vim_lib-base-dict*
---------

Класс Dict представляет изменяемый словарь данных с доступом к элемента по 
ключу. Класс реализует основные методы для доступа к элементам словаря, 
управления им и получения информации о его структуре.

Словарь Dict может быть инициализирован при инстанциации любым словарем или 
массивом следующей структуры:
>
	[[ключ, значение], ...]

либо быть пустым. Для определения или получения значений элементов словаря 
используется метод 'item'. Для выделения элементов словаря, таких как ключи,
значения и так далее, используются методы 'keys', 'vals' и 'items'. Метод
'length' позволяет определить длину (число элементов) словаря.

Пример:
>
	let s:Dict = vim_lib#base#Dict#
	let s:dct = s:Dict.new({'a': 1})
	call s:dct.item('b', 2)
	echo s:dct.length()     " 2
	echo s:dct.item('a')    " 1
	echo s:dct.keys()       " ['a', 'b']

2.5. Test						*vim_lib-base-test*
---------

Класс Test является родителем для модульных тестов, используемых в библиотеке.
Его так же можно использовать для тестирования собственных классов и плагинов.
Класс не является потомком класса Object, потому имеет несколько отличную
структуру, делающую его дочернии классы службами, нежели объектами.

Для создания модульного теста, необходимо:

  - Создать рекурсивную копию класса Test
  - Определить методы для тестирования
  - Выполнить тестирование

Так как Test не является потомком класса Object, для создания новых классов на
его базе используется рекурсивное копирование:
>
	let s:Dict = vim_lib#base#Dict#
	let s:Test = deepcopy(vim_lib#base#Test#)

При этом результирующий класс получает весь необходимый функционал для 
тестирования.

Тесты создаются в виде методов класса, имя которых должно начинаться с 'test'.
В них создается подходящее окружение и оцениваются результаты работы с помощью 
методов 'assert':
>
	function! s:Test.testItem
		let s:obj = s:Dict.new()
		call s:obj.item('a', 1)
		call self.assertEquals(s:obj.item('a'), 1)
		call self.assertEquals(s:obj.length(), 1)
	endfunction

Естественно, тестирующий метод должен быть построен таким образом, чтобы после
его выполнения система находилась в начальном состоянии. Должны быть удалены
все глобальные переменные, которые были созданы внутри метода, либо их
значение должно быть восстановлено.

Для тестирования выброса исключений, используется следующая схема:
>
	function! s:Test.testItem_throwException
		let l:obj = s:Dict.new()
		try
		  call l:obj.item('a')
		  call self.fail('testItem', 'Expected not found')
		catch /IndexOutOfRangeException:.*/
		endtry
	endfunction

Здесь, с помощью метода 'fail' мы определяем провальность теста.

В конце модульного теста необходимо вызвать метод 'run', который будет
выполнять тестирование:
>
	call s:Test.run()

Метод так же может принимать в качестве единственного параметра имя
тестирующего метода. В этом случае тестироваться будут не все методы, а только
заданный:
>
	call s:Test.run('testItem')

Важно помнить, что каждый тестирующий метод должен проверять работы одного
конкретного требования, а не тестировать весь функционал метода. В связи с
этим, для тестирования одного метода класса часто используется несколько
тестирующих методов.

================================================================================
3. Пакет sys						*vim_lib-sys*

Пакет sys включает классы, представляющие различные компоненты редактора (за
исключением визуальных), а так же расширения.

3.1. Buffer						*vim_lib-sys-buffer*
-----------

Класс Buffer представляет новые или открытые буферы редактора. Класс управляет
как опциями и привязками горячих клавишь в буфере, так и открытием новых окон
для их отображения.

Для управления существующим буфером достаточно создать объект данного класса,
передав в конструктор номер целевого буфера:
>
	let s:Buffer = vim_lib#sys#Buffer#
	let s:buf = s:Buffer.new(bufnr('%')) " Текущий буфер

Безвозвратно удалить буфер можно с помощью метода 'delete'.

Так как буфер может быть выгружен из редактора, с помощью данного класса его
можно вновь загрузить в активное окно с помощью метода 'active'. Данный метод
очень важен, так как не только активирует вызываемый буфер, но и создает все
привязки горячих кралишь и локальные опции, определенные методами 'option' и
'listen' для данного буфера. Если необходимо загрузить буфер в новое окно,
используются аналогичные методы 'gactive' (окно с горизонтальным разделением)
и 'vactive' (окно с вертикальным разделением), которые, как и метод 'active',
выполняют все привязки и задают опции буфера.

Пример:
>
	call s:buf.gactive() " Открыть буфер в новом, горизонтальном окне
	let s:newBuf = s:Buffer.new() " Новый, пустой буфер
	call s:newBuf.active() " Открыть новый буфер в текущем окне

Для определения локальных опций буфера, как уже было сказано ранее,
используется метд 'option'. Он запоминает все установленные значения опций и
применяет их к буферу при каждой его активации.

Пример:
>
	call s:buf.option('filetype', 'cpp')       " Определение типа файла
	call s:buf.option('fileencoding', 'utf-8') " Определение кодировки файла
	call s:buf.active()                        " Применение опций

Как и опции, можно задать привязки горячих клавишь для буфера с помощью метода
'listener'. Этот метод запоминает все привязки и применяет их к буферу при
каждой его активации. По наступлению события привязки (нажата целевая
клавиша), будет вызван определенный для метод-слушатель объекта буфера:
>
	function! s:buf.sayHello()
		echo 'Hello world'
	endfunction 
	call s:buf.listen('n', 'q', 'sayHello') " При нажатии q будет вызван
                                                " метод sayHello объекта

Метод-слушатель вызывается от имени исходного буфера, что позволяет
использовать переменную 'self'.

Для отмены привязок используется метод 'ignore'.

Объекты данного класса являются постоянными. Это хорошо видно на следующем 
примере:
>
	let s:bufA = s:Buffer.current() " Текущий буфер
	let s:bufA.test = 1
	let s:bufB = s:Buffer.current() " Текущий буфер
	echo s:bufB.test " 1

Важной функцией для работы с новыми, пустыми буферами является механизм
рендеринга содержимого. Если создается новый буфер, с помощью класса Buffer
его можно заполнить при активации некоторой строкой, либо использовать команду
редактора или заготовленный метод объекта буфера. Делается это с помощью
свойства/метода 'render'. Это свойство может принимать следующие значения:

  - Команда редактора - в этом случае заданная команда будет выполнена, а ее
    результат попадет в тело буфера
  - Строка - в этом случае строка будет помещена в тело буфера
  - Функция - в этом случае возвращаемая функцией строка будет помещена в тело
    буфера. Так как функция представляет метод объекта буфера, она вызывается
    от его имени, что позволяет использовать в ней переменную 'self'

Пример:
>
	let s:buf = s:Buffer.new()
	let s:buf.render = "'Hello world'"  " Строка в качестве значения
	" или
	let s:buf.render = "system('date')" " Команда редактора
	" или
	function! s:buf.render()            " Метод буфера
		return self.getNum()
	endfunction
	call s:buf.gactive() " Использование render для заполнения буфера

Ниже приведен пример создания нового буфера с указанием опций и привязок:
>
	let s:buf = s:Buffer.new()
	call s:buf.option('filetype', 'myFile')
	call s:buf.listen('n', 'q', 'delete') " Закрытие буфера по клавише q
	let s:buf.render = "system('date')"   " Буфер содержит текущую дату
	call s:buf.gactive()

3.2. Plugin						*vim_lib-sys-plugin*
-----------

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren,
no sea takimata sanctus est Lorem ipsum dolor sit amet.

3.3. NullPlugin						*vim_lib-sys-nullplugin*
---------------

Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At
vero eos et accusam et justo duo dolores et ea rebum.

================================================================================
vim:tw=78:ts=8:ft=help:norl:colorcolumn=+3:
