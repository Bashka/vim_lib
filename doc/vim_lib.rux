*vim_lib.txt*		Для Vim версии 7.0.		*vim_lib*

			РУКОВОДСТВО ПО VIM_LIB

1. Описание						|vim_lib-description|
2. Пакет base						|vim_lib-base|
  2.1. Object						|vim_lib-base-object|
  2.2. Stack						|vim_lib-base-stack|
  2.3. List						|vim_lib-base-list|
  2.4. Dict						|vim_lib-base-dict|
  2.5. Test						|vim_lib-base-test|
  2.6. File						|vim_lib-base-file|
3. Пакет sys						|vim_lib-sys|
  3.1. Buffer						|vim_lib-sys-buffer|
  3.2. Content						|vim_lib-sys-content|
  3.3. Plugin						|vim_lib-sys-plugin|
  3.4. NullPlugin					|vim_lib-sys-nullplugin|
  3.5. Publisher					|vim_lib-sys-publisher|

================================================================================
1. Описание						*vim_lib-description*

Vim_Lib - это объектно-ориентированная библиотека, включающая множество
готовых решений низкоуровневых задач на языке VimScript. Библиотека
подключается в виде autoload плагина, что позволяет загружать ее компоненты
"по требованию".

Библиотека имеет многоуровневую, вложенную структуру, которая включает:

  - Пакеты - каталоги классов, группирующие их по области применения. К ним
    относятся такие пакеты, как |vim_lib-base|, |vim_lib-sys| и так далее
  - Классы - минимальные компоненты библиотеки, решающие конкретные задачи и
    объединяющие общую логику. К ним относятся такие классы, как 
    |vim_lib-base-Object|, |vim_lib-base-Stack|, |vim_lib-sys-Plugin| и так далее

Все классы библиотеки являются дочерними, по отношению к классу 
|vim_lib-base-Object|, что унифицирует их интерфейс и приводит к единому
формату использования, а именно:
>
	let s:Stack = vim_lib#base#Stack# " Создаем псевдоним (alias) класса
	let s:stk = s:Stack.new()         " Инстанциируем класс
	" Используем объект
	let s:stk.push(1)
	echo s:stk.pop()

Из примера видно, что программный код, использующий любой класс библиотеки,
состоит из трех компонентов:

  - Создание псевдонима - данная операция позволяет не только сократить имя
    класса, но и явно назвать те компоненты библиотеки, которые используются
    данным кодом
  - Инстанциация класса - создание экземпляра класса с помощью конструктора new 
  - Использование объекта - применение объекта для решения конкретных задач

Помимо классов, библиотека включает подробную документацию их интерфейса и
модульные тесты, гарантирующие ожидаемую работу компонентов. Документация
содержится внутри файлов классов, а тесты в каталогах "tests" каждого пакета
библиотеки.

================================================================================
2. Пакет base						*vim_lib-base*

Пакет base включает базовые, низкоуровневые классы библиотеки.

2.1. Object						*vim_lib-base-object*
-----------

Класс Object является родителем всех классов библиотеки и реализует базовый 
интерфейс объектов, а именно:

  - Структура объектов - свойства 'class' и 'parent', определенные во всех 
    объектах
  - Конструктор - метод 'new', используемый для инстанциации класса
  - Механизм наследования - метод 'expand', используемый для расширения
    функциональности класса за счет реализации его потомков
  - Базовая типизация - метод 'typeof', используемый для определения
    принадлежности класса к целевой иерархии наследования

Все объекты класса Object или его подклассов представляют обычные словари. При
этом свойства определены как экземпляры этих словарей, а методы как 'dict' 
функции. Для связи объекта с классом, его породившим, создается свойство
'class', которое ссылается на объект класса (классы такой ссылки не имеют). 
Если объект является экземпляром подкласса, то в нем определяется свойство 
'parent', содержащее ссылку на соответствующий объект надкласса. Аналогичную 
ссылку имеют все подклассы. Другими словари при создании объекта дочернего 
класса, автоматически создаются объекты всех надклассов, связанные снизу вверх 
с помощью свойства 'parent'. Такое решение позволяет не смешивать свойства 
объектов между собой, а так же разделять логику конструктора между объектами.

Для создания объекта, достаточно воспользоваться конструктором 'new':
>
	let s:obj = s:MyClass.new() " Метод может принимать параметры

Конструктор, как и все методы класса Object, является статичным, то есть не
переносятся в экземпляр класса, что не позволяет вызвать конструктор от имени
объекта. Если же необходимо создать объект того же класса, что и исходный
объект, необходимо использовать ссылку 'class':
>
	let s:otherObj = s:obj.class.new() " class ссылается на s:MyClass

Программист может самостоятельно объявить статичные методы класса. Для этого
метод должен начинаться с двух символов подчеркивания (__).

Пример:
>
	function! s:MyClass.__myStaticMethod()
		echo 'Hello world'
	endfunction

Основой целью класса Object является реализация механизма наследования и
расширения существующих классов. Это достигается благодаря методу 'expand'.
Для расширения класса через наследование необходимо:

  - Использовать метод 'expand' у надкласса для создания заготовки
  - Реализовать конструктор 'new'
  - Реализовать методы класса

Метод 'expand' создает новый словарь и добавляет к нему все методы класса
Object, а так же свойство 'parent', которое ссылается на родительский класс.
Этот словарь будет возвращен из метода и определит заготовку будущего класса.

Для реализации конструктора нового класса необходимо переопределить метод
'new' для заготовки, создаваемой методом 'expand'. Конструктор может принимать
любое число аргументов, с помощью которых будут инициализировать экземпляры
этого класса. Конструктор должен создавать новые словари для всех надклассов, 
определять ссылки 'class' и 'parent', а так же инициализировать свойства
будущего объекта. Сделать это можно следующим способом:

  - Создать заготовку объекта с помощью метода 'bless' класса Object, передав
    ему результат работы конструктора надкласса
  - Определить для полученной заготовки свойства не переопределяя ссылки
    'parent' и 'class'
  - Вернуть получившийся объект 

После определения конструктора класса, необходимо реализовать его методы. Для
этого достаточно создать 'dict' функции для полученного класса, которые будут
обращаться к свойствам экземпляров этого класса через переменную 'self':
>
	function! s:MyClass.getA()
		return self.a
	endfunction

Важно помнить, что методы класса относятся к тому объекту, в классе которого
они были объявлены. Так, если в классе Parent реализован метод getA, то в
объекте его подкласса Child, этот метод будет доступен только через ссылку
'parent' объекта:
>
	echo s:child.parent.getA()

Это связано с тем, что для каждого класса создается отдельный объект, хранящий
его свойства.

Более подробно познакомиться с механизмом наследования вы можете на примере
классов "vim_lib/autoload/base/tests/Object/Parent" и 
"vim_lib/autoload/base/tests/Object/Child".

2.2. Stack						*vim_lib-base-stack*
----------

Класс Stack представляет список данных, организованный по принципу LIFO. Класс
реализует несколько методов манипулирования стеком, а так же метод 'length',
вычисляющий текущую длину стека (число элементов в нем).

Изначально экземпляр данного класса пуст, для добавления в него элементов
используется метод 'push', который вставляет данные в ввершину стека. Метод
'pop' наоборот выталкивает данные из вершины и возвращает их. Если необходимо
получить данные с вершины стека без выталкивания, используется метод
'current'.

Пример:
>
	let s:Stack = vim_lib#base#Stack#
	let s:stk = s:Stack.new()
	call s:stk.push(1)
	call s:stk.push(2)
	echo s:stk.length() " 2
	echo s:stk.pop()    " 2
	echo s:stk.pop()    " 1
	echo s:stk.length() " 0

2.3. List						*vim_lib-base-list*
---------

Класс List представляет упорядоченный, изменяемый список данных с доступом к 
элемента по индексу. Класс реализует основные методы для доступа к элементам 
списка, управления им и получения информации о его структуре.

Список List может быть инициализирован при инстанциации любым массивом, либо
быть пустым. Для определения или получения значений элементов списка 
используется метод 'item'. Для выделения среза используется метод 'sec'. Метод
'length' позволяет определить длину (число элементов) списка.

Пример:
>
	let s:List = vim_lib#base#List#
	let s:lst = s:List.new([1,2,3])
	call s:lst.item(0, 5)
	echo s:lst.item(0)    " 5
	echo s:lst.length()   " 3
	echo s:lst.list()     " [5,2,3]

2.4. Dict						*vim_lib-base-dict*
---------

Класс Dict представляет изменяемый словарь данных с доступом к элемента по 
ключу. Класс реализует основные методы для доступа к элементам словаря, 
управления им и получения информации о его структуре.

Словарь Dict может быть инициализирован при инстанциации любым словарем или 
массивом следующей структуры:
>
	[[ключ, значение], ...]

либо быть пустым. Для определения или получения значений элементов словаря 
используется метод 'item'. Для выделения элементов словаря, таких как ключи,
значения и так далее, используются методы 'keys', 'vals' и 'items'. Метод
'length' позволяет определить длину (число элементов) словаря.

Пример:
>
	let s:Dict = vim_lib#base#Dict#
	let s:dct = s:Dict.new({'a': 1})
	call s:dct.item('b', 2)
	echo s:dct.length()     " 2
	echo s:dct.item('a')    " 1
	echo s:dct.keys()       " ['a', 'b']

2.5. Test						*vim_lib-base-test*
---------

Класс Test является родителем для модульных тестов, используемых в библиотеке.
Его так же можно использовать для тестирования собственных классов и плагинов.
Класс не является потомком класса Object, потому имеет несколько отличную
структуру, делающую его дочернии классы службами, нежели объектами.

Для создания модульного теста, необходимо:

  - Создать заготовку тестирующего класса с помощью метода 'expand' класса Test
  - Определить методы для тестирования
  - Выполнить тестирование

Как и потомки класса Object, для создания потомка класса Test используется
метод 'expand':
>
	let s:Dict = vim_lib#base#Dict#
	let s:Test = vim_lib#base#Test#.expand()

При этом результирующий класс получает весь необходимый функционал для 
тестирования.

Тесты создаются в виде методов класса, имя которых должно начинаться с 'test'.
В них создается подходящее окружение и оцениваются результаты работы с помощью 
методов 'assert':
>
	function! s:Test.testItem
		let s:obj = s:Dict.new()
		call s:obj.item('a', 1)
		call self.assertEquals(s:obj.item('a'), 1)
		call self.assertEquals(s:obj.length(), 1)
	endfunction

Естественно, тестирующий метод должен быть построен таким образом, чтобы после
его выполнения система находилась в начальном состоянии. Должны быть удалены
все глобальные переменные, которые были созданы внутри метода, либо их
значение должно быть восстановлено.

Для тестирования выброса исключений, используется следующая схема:
>
	function! s:Test.testItem_throwException
		let l:obj = s:Dict.new()
		try
		  call l:obj.item('a')
		  call self.fail('testItem', 'Expected not found')
		catch /IndexOutOfRangeException:.*/
		endtry
	endfunction

Здесь, с помощью метода 'fail' мы определяем провальность теста.

В конце модульного теста необходимо вызвать метод 'run', который будет
выполнять тестирование:
>
	call s:Test.run()

Метод так же может принимать в качестве единственного параметра имя
тестирующего метода. В этом случае тестироваться будут не все методы, а только
заданный:
>
	call s:Test.run('testItem')

Важно помнить, что каждый тестирующий метод должен проверять работы одного
конкретного требования, а не тестировать весь функционал метода. В связи с
этим, для тестирования одного метода класса часто используется несколько
тестирующих методов.

2.6. File						*vim_lib-base-file*
---------

Класс File служит для объектного представления компонентов файловой системы в
редакторе. Объекты данного класса представляют как файлы, так и каталоге, при
чем не обязательно существующие в данный момент.

Не смотря на то, что класс является подклассом Object, конструкторов в нем
два. Это связано с разными схемами инстанциации, а именно:

  - Метод 'absolute' - создание объекта по абсолютному пути к файлу;
  - Метод 'relative' - создание объекта по относительному пути к файлу. Пусть
    расчитывается от каталога текущего файла.

Важно помнить, что конструктор 'relative' расчитывает пусть относительно
текущего файла редактора, а не адреса скрипта, в котором он исопльзуется. Так,
вызов конструктора каким либо плагином для доступа к файлам этого плагина
может привести к созданию неверного пути, так как основанием пути будет не
этот плагин, а текущий файл редактора. Для решения этой проблемы, можно
использовать абсолютные пути и метод 'expand':
>
	let s:File = vim_lib#base#File#
	let s:f = s:File.absolute(expand('<sfile>') . '/Storage/base.db')

Класс предоставляет подробную информацию о своем пути с помощью методов
'getName', 'getDir' и 'getAddress'.

Пример:
>
	echo s:f.getName() " base.db
	echo s:f.getDir().getName() " Storage
	echo s:f.getAddress() " /.../Storage/base.db

Метод 'isExists' позволяет не только определить, существует ли данный
компонент (файл или каталог) в файловой системе, но и узнать о существовании
компонентов в данном каталоге:
>
	let s:dir = s:File.relative('myDir')
	if s:dir.isExists()
		echo (s:dir.isExists('myFile.txt')? 'myFile существует' : 'myFile существует'
	endif

Если компонент не существует, его можно создать с помощью методов 'createFile'
и 'createDir' для файла и каталога соответственно. Удалить файл можно с
помощью метода 'deleteFile' (удаление каталога в Vim не реализовано).

Пример:
>
	let s:newFile = s:File.relative('newFile.txt')
	call s:newFile.createFile()

Для чтения из файла используется метод 'read', который возвращает массив
строк, содержащихся в файле. Метод 'write' добавляет новую строку в файл, а
метод 'rewrite' перезаписывает файл массивом строк.

Пример:
>
	call s:f.write('New string') " Добавляем строку в конец файла
	echo s:f.read() " Читаем содержимое файла

================================================================================
3. Пакет sys						*vim_lib-sys*

Пакет sys включает классы, представляющие различные компоненты редактора (за
исключением визуальных), а так же расширения.

3.1. Buffer						*vim_lib-sys-buffer*
-----------

Класс Buffer представляет новые или открытые буферы редактора. Класс управляет
как опциями и привязками горячих клавишь в буфере, так и открытием новых окон
для их отображения.

Для управления существующим буфером достаточно создать объект данного класса,
передав в конструктор номер целевого буфера:
>
	let s:Buffer = vim_lib#sys#Buffer#
	let s:buf = s:Buffer.new(bufnr('%')) " Текущий буфер

Безвозвратно удалить буфер можно с помощью метода 'delete'.

Так как буфер может быть выгружен из редактора, с помощью данного класса его
можно вновь загрузить в активное окно с помощью метода 'active'. Данный метод
очень важен, так как не только активирует вызываемый буфер, но и создает все
привязки горячих кралишь и локальные опции, определенные методами 'option' и
'listen' для данного буфера. Если необходимо загрузить буфер в новое окно,
используются аналогичные методы 'gactive' (окно с горизонтальным разделением)
и 'vactive' (окно с вертикальным разделением), которые, как и метод 'active',
выполняют все привязки и задают опции буфера.

Пример:
>
	call s:buf.gactive() " Открыть буфер в новом, горизонтальном окне
	let s:newBuf = s:Buffer.new() " Новый, пустой буфер
	call s:newBuf.active() " Открыть новый буфер в текущем окне

Для определения локальных опций буфера, как уже было сказано ранее,
используется метд 'option'. Он запоминает все установленные значения опций и
применяет их к буферу при каждой его активации.

Пример:
>
	call s:buf.option('filetype', 'cpp')       " Определение типа файла
	call s:buf.option('fileencoding', 'utf-8') " Определение кодировки файла
	call s:buf.active()                        " Применение опций

Как и опции, можно задать привязки горячих клавишь для буфера с помощью метода
'listener'. Этот метод запоминает все привязки и применяет их к буферу при
каждой его активации. По наступлению события привязки (нажата целевая
клавиша), будет вызван определенный для метод-слушатель объекта буфера:
>
	function! s:buf.sayHello()
		echo 'Hello world'
	endfunction 
	call s:buf.listen('n', 'q', 'sayHello') " При нажатии q будет вызван
                                                " метод sayHello объекта

Метод-слушатель вызывается от имени исходного буфера, что позволяет
использовать переменную 'self'.

Для отмены привязок используется метод 'ignore'.

Объекты данного класса являются постоянными. Это хорошо видно на следующем 
примере:
>
	let s:bufA = s:Buffer.current() " Текущий буфер
	let s:bufA.test = 1
	let s:bufB = s:Buffer.current() " Текущий буфер
	echo s:bufB.test " 1

Важной функцией для работы с новыми, пустыми буферами является механизм
рендеринга содержимого. Если создается новый буфер, с помощью класса Buffer
его можно заполнить при активации некоторой строкой, либо использовать команду
редактора или заготовленный метод объекта буфера. Делается это с помощью
свойства/метода 'render'. Это свойство может принимать следующие значения:

  - Команда редактора - в этом случае заданная команда будет выполнена, а ее
    результат попадет в тело буфера
  - Строка - в этом случае строка будет помещена в тело буфера
  - Функция - в этом случае возвращаемая функцией строка будет помещена в тело
    буфера. Так как функция представляет метод объекта буфера, она вызывается
    от его имени, что позволяет использовать в ней переменную 'self'

Пример:
>
	let s:buf = s:Buffer.new()
	let s:buf.render = "'Hello world'"  " Строка в качестве значения
	" или
	let s:buf.render = "system('date')" " Команда редактора
	" или
	function! s:buf.render()            " Метод буфера
		return self.getNum()
	endfunction
	call s:buf.gactive() " Использование render для заполнения буфера

С помощью класса Buffer так же осуществляется управления окнами редактора.
Так, метод 'select' позволяет сделать текущим то окно, в котором отображается
вызваемый буфер:
>
	let s:bufCur = s:Buffer.current() " Текущий буфер
	let s:buf = s:Buffer.new()
	call s:buf.gactive() " Активным окном является окно буфера s:buf
	call s:bufCur.select() " Активным окном сделано прежнее окно

Метод 'unload' позволяет закрыть все окна, в которых активен буфер.

Ниже приведен пример создания нового буфера с указанием опций и привязок:
>
	let s:buf = s:Buffer.new()
	call s:buf.option('filetype', 'myFile')
	call s:buf.listen('n', 'q', 'delete') " Закрытие буфера по клавише q
	let s:buf.render = "system('date')"   " Буфер содержит текущую дату
	call s:buf.gactive()

3.2. Content						*vim_lib-sys-content*
-----------

Класс Content служит для управления содержимым текущего буфера. С помощью
данного класса возможно как получать, так и изменять содержимое буфера.
Важной особенностью данного класса является то, что его экземляр работает
только с текущим буфером, потому нет необходимости в более чем одном
экземпляре данного класса. Именно поэтому он является Singleton.

Так как Content, как и большинство классов библиотеки, является подклассом
класса Object, для получения его экземпляра используется конструктор 'new'.

Практически все методы данного класса могут принимать дополнительный параметр,
так и вызываться без него. В первом случае метод добавляет или заменяет данные
в буфере, во втором возвращает данные. Так, метод 'pos' без параметров
возвращает информацию о текуем положении курсора в виде словаря со следующей
структурой: {'l': номерСтроки, 'c': номерСтолбца}, но в этот метод так же
можно передать словарь аналогичной структуры (в таком случае оба элемента
являются необязательными) и метод установит курсор в заданное положение:
>
	let s:Content = vim_lib#sys#Content#
	let s:c = s:Content.new()
	echo s:c.pos() " Получить информацию о положении курсора
	echo s:c.pos({'l': 5}) " Установить курсор на пятую строку

Для изменения или получения содержимого буфера используются методы 'rewrite', 
'add', 'line', 'word' и 'WORD'.

Пример:
>
	call s:c.rewrite('Test') " Установить содержимое
	call s:c.add(1, 'Hello world') " Вставить строку Hello world в начало
	echo s:c.line(1) " Hello world
	echo s:c.line(1, 'Rewrite line') " Заменить первую строку на данную
	echo s:c.word() " Получить слово под курсором
	echo s:c.word('Test') " Заменить слово под курсором на данное

Метод 'WORD' отличается тем, что он взаимодействует со словами, ограничителями 
которых являются пробелы, но не знаки препинания, как в случае с методом 'word'.

Метод 'select' позволяет получить выделенный пользователем текст в виде строки.

3.3. Plugin						*vim_lib-sys-plugin*
-----------

Класс Plugin служит для реализации основной логики при инициализации сторонних
плагинов редактора. Основной целью данного плагина является унификация
механизмов инициализации, использования и управления плагинами.

Плагин, реализованный с использованием данного класса имеет следующую структуру:

  - Логика инициализации плагина выносится в файл с именем
    'plugin/имяПлагина.vim'. Этот скрипт включает объявление глобальной
    переменной, хранящей объект плагина, инициализацию плагина с помощью опций,
    добавление команд и привязок плагина
  - Интерфейс плагина, то есть все методы, с помощью которых выполняется
    управление плагином и редактором с его помощью, выносится в файл с именем
    'autoload/имяПлагина.vim'. Данный скрипт содержит загружаемые
    автоматически функции, являющиеся основными управляющими компонентами 
    плагина.

Инициализация плагина с помощью данного класса выполняется в несколько этапов:

  1. Создание объекта плагина
  2. Выполнение инициализации плагина
  3. Регистрация плагина

Пример:
>
	let s:Plugin = vim_lib#sys#Plugin#
	let s:p = s:Plugin.new('myPlugin', '1') " 1 этап
	function! s:p.run() " 2 этап
		...
	function
	call s:p.comm('myPlugMethod', 'method') " 2 этап
	call s:p.map('n', 'r', 'method') " 2 этап
	call s:p.reg() " 3 этап

Первый этап позволяет определить имя плагина (первый параметр метода 'new'),
его текущую версию (второй параметр) и, возможно, зависимости плагина (не
обязательый третий параметр), которые представляются с помощью словаря со
следующей структурой:

  - version - минимальная, требуемая версия редактора vim
  - has - массив модулей окружения, необходимых для работы модуля
  - plugins - массив имен плагинов редактора, необходимых для работы данного
    плагина. Данная зависимость так же определяет порядок загрузки плагина.
    Она должна производится после загрузки всех используемых плагинов.

Пример:
>
	let s:p = s:Plugin.new('myPlugin', '1', 
	\ {'version': 740, 'has': ['pithon'], 'plugins': ['vim_lib']})

Второй этап использует следующие методы для инициализации плагина:

  - run - логика инициализации плагина в свободной форме
  - comm - инициализация команд плагина
  - map - инициализация привязок плагина
  - def - инициализация опций плагина значениями по умолчанию

Важно использовать именно эти команды для инициализации плагина. Благодаря им
становится проще отключить плагин в будущем (см. |NullPlugin|).

Третий этап включает обязательный вызов метода 'reg', который создает
глобальную переменную плагина 'имяПлагина#' и присваивает ей созданный на
предыдущих этапах объект плагина. В будущем доступ к плагину осуществляется
через эту переменную. Данный метод так же выполняет некоторые системные
конфигурации для регистрации плагина.

После исталяции плагина в редактор он может быть инициализирован тремя
различными способами:

  1. Пользовательская инициализация - для инициализации опций плагина,
     пользователю достаточно добавить в скрипты, выполняющиеся до загрузки 
     плагина (такие как .vimrc) код инициализации. Этот код представляет 
     объявление глобальной переменной 'имяПлагина#' содержащий словарь опций 
     и их значений
  2. Дефолтная инициализация - данная инициализация выполняется внутри плагина
     с помощью методом 'run' и 'def'
  3. Переинициализация - для переопределения опций плагина после его загрузки
     пользователю достаточно добавить в скрипты, выполняющиеся после загрузки
     плагина (такие как ftplugin) код инициализации свойств глобального объекта 
     'имяПлагина#'

Пример пользовательской инициализации в файле .vimrc:
>
	let myPlugin# = {'option': 1}

Пример переинициализации в файле ftplugin/vim.vim
>
	let myPlugin#.option = 1

Интерфейс плагина, использующего данный класс, выносится в файл
autoload/имяПлагина.vim.

Пример:
>
	function! myPlugin#method()
		echo 'Hello world'
	endfunction

3.4. NullPlugin						*vim_lib-sys-nullplugin*
---------------

Класс Plugin позволяет легко отключить любой плагин без необходимости
добавления логики в файл инициализации плагина. Для отключения плагина
достаточно добавить в любой файл, выполняемый до загрузки плагина (на пример
.vimrc) объявление переменной 'имяПлагина#' инициализируя ее значением ноль.

Пример:
>
	let myPlugin# = 0

Если конструктор класса Plugin обнаружит наличие такой переменной со значением
ноль, он вернет объект класса NullPlugin, который включает те же методы, что и
класс Plugin, но не выполняет никаких действий. Такой подход позволяет
отменить инициализацию плагина без необходимости добавления в файл
инициализации конструкций вида:
>
	if exists('myPlugin')
		finish
	endif

3.5. Publisher						*vim_lib-sys-publisher*
--------------

Класс Publisher реализует событийную модель в редакторе Vim. Любой скрипт
может использовать данный класс как для обработки событий других скриптов, так
и для информирования их о собственных событиях.

Для добавления обработчика события необходимо определить глобальную функцию,
которая и будет являться обработчиком события, а затем зарегистрировать ее в
качестве обработчика с помощью метода 'listen':
>
	let s:Publisher = vim_lib#sys#Publisher#
	let s:p = s:Publisher.new()
	function! MyListener(event)
		...
	endfunction
	call s:p.listen('MyEvent', function('MyListener'))

Обратите внимание на то, что функция обработчик имеет единственный аргумент
'event'. Этим параметром в функцию будет передан объект, представляющий
событие. Данный объект используется для получения информации о событии.

Если необходимо прекратить обработку некоторого события, используется метод
'ignore':
>
	call s:p.ignore('MyEvent', function('MyListener') " Отменить обработчик
	call s:p.ignore('MyEvent') " Отменить все обработчики события

Если ваш скрипт создает события, то с помощью класса Publisher о них можно
оповестить всех подписчиков. Для этого используется метод 'fire':
>
	call s:p.fire('MyEvent') " Выброс события
	call s:p.fire('MyEvent', {'plugin': 'myPlugin'}) " Выброс события с объектом

В таком случае будут вызваны все обработчики указанного события. Если передать
в качестве второго параметра объект, он будет передан в качестве единственного
параметра обработчику.

Обработчики вызываются в порядке их добавления методом 'listen'. Так же
возможно добавить один и тот же обработчик одного и того же события более
одного раза:
>
	call s:p.listen('MyEvent', function('MyListener'))
	call s:p.listen('MyEvent', function('MyListener'))

Для разделения событий плагинов, рекомендуется использовать префикс имени 
события:
>
	call s:p.listen('myPlugin#MyEvent', function('MyListener')) " Обработчик
	call s:p.fire('myPlugin#MyEvent') " Выброс события плагином

================================================================================
vim:tw=78:ts=8:ft=help:norl:colorcolumn=+3:
